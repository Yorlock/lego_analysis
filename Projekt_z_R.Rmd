---
title: "Projekt_z_R"
author: "Dominik Łukasiewicz"
date: "`r Sys.Date()`"
output:
  html_document: 
    toc: yes
    toc_float: true
    number_sections: yes
  word_document: default
  pdf_document: default
---

# Wstęp
Celem projektu jest analiza bazy danych Lego na przestrzeni lat.

# Przygotowanie środowiska
## Wykorzystane biblioteki

```{r, message=F, echo=F, warning=F}

library(knitr)
library(dplyr)
library(DT)
library(png)
library(skimr)
library(plotly)
library(ggplot2)
library(caret)

prettyTable <- function(table_df, round_digits=2) {
    DT::datatable(table_df, style="bootstrap", filter = "top", rownames = FALSE, extensions = "Buttons", options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print'))) %>% formatRound(names(dplyr::select_if(table_df, is.numeric)), round_digits)
}

opts_chunk$set(echo=F, message = F, warning = F)
```

- knitr - tworzenie raportów w R
- dplyr - przetwarzanie danych
- DT - wyświetlanie interaktywnych tabel
- png - wczytywanie i pokazywanie zdjęć
- skimr - tworzenie podsumowania danych
- ggplot2 - tworzenie wykresów
- plotly - tworzenie interaktywnych wykresów
- caret - uczenie maszynowe

## Ustawienie powtarzalność wyników
W celu zapewnienia powtarzalności wyników ziarno zostało ustawione na 23.

```{r, echo=T}
set.seed(23)
```

```{r, cache=T}
unzip("data.zip")
```

# Schemat danych
```{r, cache=T, echo=T}
rebrickable_schema <- readPNG("data/rebrickable_schema_v3.png")
grid::grid.raster(rebrickable_schema)
```

# Wstępne przetwarzanie danych
## Wczytanie danych
```{r, cache=T, echo=T}
colors_raw <- read.csv("data/colors.csv", header = T, sep = ",")
elements_raw <- read.csv("data/elements.csv", header = T, sep = ",")
inventories_raw <- read.csv("data/inventories.csv", header = T, sep = ",")
inventory_minifigs_raw <- read.csv("data/inventory_minifigs.csv", header = T, sep = ",")
inventory_parts_raw <- read.csv("data/inventory_parts.csv", header = T, sep = ",")
inventory_sets_raw <- read.csv("data/inventory_sets.csv", header = T, sep = ",")
minifigs_raw <- read.csv("data/minifigs.csv", header = T, sep = ",")
part_categories_raw <- read.csv("data/part_categories.csv", header = T, sep = ",")
part_relationships_raw <- read.csv("data/part_relationships.csv", header = T, sep = ",")
parts_raw <- read.csv("data/parts.csv", header = T, sep = ",")
sets_raw <- read.csv("data/sets.csv", header = T, sep = ",")
themes_raw <- read.csv("data/themes.csv", header = T, sep = ",")
```
## Przetwarzanie brakujących danych
### Colors
Brak modyfikacji surowych danych
```{r, echo=T}
colors_clean <- colors_raw
```
### Elements
Usunięcie nadmiarowej kolumny design_id, która nie miała wykorzystania w schemacie 
```{r, echo=T}
elements_clean <- elements_raw[, -4]
```
### Inventories
Brak modyfikacji surowych danych
```{r, echo=T}
inventories_clean <- inventories_raw
```
### Inventory Minifigs
Brak modyfikacji surowych danych
```{r, echo=T}
inventory_minifigs_clean <- inventory_minifigs_raw
```
### Inventory Parts
Usunięcie nadmiarowej kolumny img_url, która nie podlega analizie
```{r, echo=T}
inventory_parts_clean <- inventory_parts_raw[, -6]
```
### Inventory Sets
Brak modyfikacji surowych danych
```{r, echo=T}
inventory_sets_clean <- inventory_sets_raw
```
### Minifigs
Usunięcie nadmiarowej kolumny img_url, która nie podlega analizie
```{r, echo=T}
minifigs_clean <- minifigs_raw[, -4]
```
### Part Categories
Brak modyfikacji surowych danych
```{r, echo=T}
part_categories_clean <- part_categories_raw
```
### Part Relationships
Brak modyfikacji surowych danych
```{r, echo=T}
part_relationships_clean <- part_relationships_raw
```
### Parts
Brak modyfikacji surowych danych
```{r, echo=T}
parts_clean <- parts_raw
```
### Sets
Usunięcie nadmiarowej kolumny img_url, która nie podlega analizie
```{r, echo=T}
sets_clean <- sets_raw[, -6]
```
### Themes
Brak modyfikacji surowych danych
```{r, echo=T}
themes_clean <- themes_raw
```
## Podstawowe statystyki
### Colors
```{r, echo=T}
knitr::kable((head(colors_clean)))
skim(colors_clean)
```
### Elements
```{r, echo=T}
knitr::kable((head(elements_clean)))
skim(elements_clean)
```
### Inventories
```{r, echo=T}
knitr::kable((head(inventories_clean)))
skim(inventories_clean)
```
### Inventory Minifigs
```{r, echo=T}
knitr::kable((head(inventory_minifigs_clean)))
skim(inventory_minifigs_clean)
```
### Inventory Parts
```{r, echo=T}
knitr::kable((head(inventory_parts_clean)))
skim(inventory_parts_clean)
```
### Inventory Sets
```{r, echo=T}
knitr::kable((head(inventory_sets_clean)))
skim(inventory_sets_clean)
```
### Minifigs
```{r, echo=T}
knitr::kable((head(minifigs_clean)))
skim(minifigs_clean)
```
### Part Categories
```{r, echo=T}
knitr::kable((head(part_categories_clean)))
skim(part_categories_clean)
```
### Part Relationships
```{r, echo=T}
knitr::kable((head(part_relationships_clean)))
skim(part_relationships_clean)
```
### Parts
```{r, echo=T}
knitr::kable((head(parts_clean)))
skim(parts_clean)
```
### Sets
```{r, echo=T}
knitr::kable((head(sets_clean)))
skim(sets_clean)
```
### Themes
```{r, echo=T}
knitr::kable((head(themes_clean)))
skim(themes_clean)
```
# Analiza danych

```{r}
top_colors <- 15
```

## Analiza wykorzystanych kolorów w elementach
Poniższy wykres ukazuje `r top_colors` najczęściej używanych kolorów w elementach.
Warte również uwagi jest fakt, iż za brak koloru uważa się kolor czarny.

```{r, echo=F}
elements_with_colors_df <- left_join(elements_clean, colors_clean, by = join_by(color_id == id))

sum_most_used_colors_df <- data.frame(table(elements_with_colors_df$name))

colnames(sum_most_used_colors_df) <- c("Color", "Quantity")

sum_most_used_colors_df <- sum_most_used_colors_df %>%
  arrange(desc(Quantity)) %>%
  head(top_colors)

sorted_colors_with_rgb <-left_join(sum_most_used_colors_df, colors_clean, by = join_by(Color == name)) %>%
  arrange(desc(Quantity))

rgb_names_list <- sorted_colors_with_rgb %>%
  select(rgb) %>%
  c() %>%
  lapply(function(x) paste0("#", x))

color_names_list <- sorted_colors_with_rgb %>%
  select(Color) %>%
  c()

rgb_color_pairs <- setNames(rgb_names_list$rgb, color_names_list$Color)

most_used_colors_plot <- ggplot(sum_most_used_colors_df, aes(x = reorder(Color, Quantity), y = Quantity, fill = Color, color = "black")) +
  geom_bar(stat = "identity", position = "identity") +
  labs(title = "Najczęściej używany kolor w elementach", x = "Color", y = "Quantity") +
  scale_fill_manual(values=rgb_color_pairs) +
  coord_flip() +
  theme_minimal() +
  theme(legend.position = "none")

ggplotly(most_used_colors_plot, tooltip = c("Color", "Quantity"))

```

```{r}
top_minifigs <- 10
```
## Analiza najczęściej używanych minifigach w zestawach
Poniższe wykresy ukazuje `r top_minifigs` najczęściej używanych minifigów w zestawach.
Pierwszy wykres agreguje dane po nazwach, natomiast drugi po unikalnych indeksach.
Analizując uzyskane wyniki możemy dostrzeć, że wyniki różnią się.
Wynika to z faktu, iż istnieją minifigi posiadające taką samą nazwę, ale różniącą się indeksem.
Takie minifigi różnią się najczęściej barwą kolorów, ilością zastosowanych elementów lub materiałem z których zostały wykonane.
```{r, echo=F}
minifigs_with_inventory_df <- left_join(minifigs_clean, inventory_minifigs_clean, by = join_by(fig_num == fig_num))

sum_most_used_minifigs_by_name_df <- minifigs_with_inventory_df %>%
  select(fig_num, name, quantity) %>%
  group_by(name) %>%
  summarise(sum_of_quantity = sum(quantity)) %>%
  arrange(desc(sum_of_quantity)) %>%
  head(top_minifigs)

colnames(sum_most_used_minifigs_by_name_df) <- c("Minifig", "Quantity")

sum_most_used_minifigs_by_fig_df <- minifigs_with_inventory_df %>%
  select(fig_num, name, quantity) %>%
  group_by(fig_num, name) %>%
  summarise(sum_of_quantity = sum(quantity)) %>%
  arrange(desc(sum_of_quantity)) %>%
  head(top_minifigs)

colnames(sum_most_used_minifigs_by_fig_df) <- c("Fig_num", "Minifig", "Quantity")

most_used_minifig_by_name_plot <- ggplot(sum_most_used_minifigs_by_name_df, aes(x = reorder(Minifig, Quantity), y = Quantity, fill = Minifig, color = "black")) +
  geom_bar(stat = "identity", position = "identity") +
  labs(title = "Najczęściej używane minifigi w \nzestawach agregując po nazwach", x = "Minifig", y = "Quantity") +
  coord_flip() +
  scale_fill_brewer(palette="Set3") +
  theme_minimal() +
  theme(legend.position = "none")

most_used_minifig_by_fig_plot <- ggplot(sum_most_used_minifigs_by_fig_df, aes(x = reorder(Minifig, Quantity), y = Quantity, fill = Minifig, color = "black")) +
  geom_bar(stat = "identity", position = "identity") +
  labs(title = "Najczęściej używane minifigi w \nzestawach agregując po indeksach", x = "Minifig", y = "Quantity") +
  coord_flip() +
  scale_fill_brewer(palette="Set3") +
  theme_minimal() +
  theme(legend.position = "none")

ggplotly(most_used_minifig_by_name_plot, tooltip = c("Minifig", "Quantity"))
ggplotly(most_used_minifig_by_fig_plot, tooltip = c("Minifig", "Quantity"))
```

```{r}
parts_with_categories_df <- left_join(parts_clean, part_categories_clean, by = join_by(part_cat_id == id))
parts_with_categories_and_elements_df <- left_join(parts_with_categories_df, elements_clean, by = join_by(part_num == part_num))
parts_full_data_df <- left_join(parts_with_categories_and_elements_df, colors_clean, by = join_by(color_id == id))
```

## Liczba części z i bez elementów
Wykres przestawia porównanie liczbę części zawierającej element z tymi, które są bez elementów
```{r}
is_element_na <- is.na(parts_with_categories_and_elements_df$element_id)

parts_without_elements_df <- parts_with_categories_and_elements_df[is_element_na, ] %>%
  select(-element_id, -color_id)

parts_with_elements_df <- parts_with_categories_and_elements_df[!is_element_na, ] %>%
  select(-element_id)

count_parts_with_without_elements_df <- data.frame(
  category = c("with_elements", "without_elements"),
  count = c(nrow(parts_with_elements_df), nrow(parts_without_elements_df)))

ggplot(count_parts_with_without_elements_df, aes(x = category, y = count, fill = category)) +
  geom_bar(stat = "identity", position = "identity") +
  labs(title = "Liczba części z i bez elementów", x = "Category", y = "Count") +
  theme_bw() +
  scale_color_brewer(palette = "Paired") +
  theme(legend.position = "none")
```

## Liczba elementów z i bez kolorów
Wykres przestawia porównanie liczbę elementów zawierającej jakiś kolor z tymi, które są bez koloru
```{r}

is_color_na <- is.na(parts_full_data_df$color_id)
parts_without_color_df = parts_full_data_df[is_color_na, ]
parts_with_color_df = parts_full_data_df[!is_color_na, ]

count_color_parts_df <- data.frame(
  category = c("with_color", "without_color"),
  count = c(nrow(parts_with_color_df), nrow(parts_without_color_df)))

ggplot(count_color_parts_df, aes(x = category, y = count, fill = category)) +
  geom_bar(stat = "identity", position = "identity") +
  labs(title = "Liczba części z i bez kolorów", x = "Category", y = "Count") +
  theme_bw() +
  scale_color_brewer(palette = "Paired") +
  theme(legend.position = "none")
```

## Lista używanych materiałów do tworzenia elementów
Tabela przedstawia jakie materiały oraz w jakiej ilości są wykorzystywane w produkowanych elementach.
Jak widać, plastik stanowi znaczącą część wszystkich wykorzystywanych elementów, co widać wyraźnie na wykresie porównujących plastik do pozostałych materiałów.
```{r}
sum_of_used_materials_df <- parts_clean %>%
  select(part_material) %>%
  count(part_material)

prettyTable(sum_of_used_materials_df)

everything_but_plastic_count <- sum_of_used_materials_df %>%
  select(part_material, n) %>%
  filter(part_material != "Plastic") %>%
  mutate(all_n = sum(n)) %>%
  select(all_n) %>%
  head(1) %>%
  as.numeric()

plastic_count <- sum_of_used_materials_df %>%
  select(part_material, n) %>%
  filter(part_material == "Plastic") %>%
  select(n) %>%
  head(1) %>%
  as.numeric()

compare_plastic_other_df <- data.frame(category = c("Other", "Plastic"), count = c(everything_but_plastic_count, plastic_count))

ggplot(compare_plastic_other_df, aes(x = category, y = count, fill = category)) +
  geom_bar(stat = "identity", position = "identity") +
  labs(title = "Porównanie wykorzystania plastiku do reszty materiałów", x = "Category", y = "Count") +
  theme_bw() +
  scale_color_brewer(palette = "Paired") + 
  theme(legend.position = "none")
```

```{r}
current_year <- as.integer(format(Sys.Date(), "%Y"))
```

## Wzrost liczby setów od początku do roku `r current_year - 1`
Wykres przedstawia ile zostało zaprojektowanych setów w każdym roku.
Dodatkowo zaprezentowane jest całkowita liczba zaprojektowanych setów dla każdego roku.
```{r}
set_without_current_year_df <- sets_clean[!(sets_clean$year %in% c(current_year, current_year + 1, current_year + 2)), ]

grouped_by_year_sum_df <- set_without_current_year_df %>%
  group_by(year) %>%
  summarise(count_sets = n()) %>%
  mutate(cumcount_sets = cumsum(count_sets))

colnames(grouped_by_year_sum_df) <- c("Year", "Count_sets", "Cumulative_count_of_sets")

grouped_by_year_plot <- ggplot(grouped_by_year_sum_df, aes(x = Year, y = Count_sets)) +
  geom_bar(stat = "identity") +
  geom_line(aes(y = Cumulative_count_of_sets), color = "red") +
  labs(title = "Suma liczby setów dla każdego roku", x = "Year", y = "Sum of sets") +
  theme_bw() +
  scale_color_brewer(palette = "Paired")

ggplotly(grouped_by_year_plot)
```

```{r}
top_themes = 15
```

## Top `r top_themes` tematów na podstawie ilości setów
```{r}
themes_without_parent_df <- themes_clean %>% 
  select(-parent_id)

themes_with_parents_df <- left_join(themes_clean, themes_without_parent_df, by = join_by(parent_id == id), suffix = c("_child", "_parent")) %>%
  select(-parent_id) %>%
  mutate(name_parent = ifelse(is.na(name_parent), name_child, name_parent))

sets_themes_df <- left_join(sets_clean, themes_with_parents_df, by = join_by(theme_id == id)) %>%
  select(-set_num, -theme_id, -name)

top_n_themes_data_df <- sets_themes_df %>%
  group_by(name_parent) %>%
  summarize(Count_sets = n()) %>%
  arrange(desc(Count_sets)) %>%
  head(top_themes)

top_n_themes_plot <- ggplot(top_n_themes_data_df, aes(x=reorder(name_parent, Count_sets), y=Count_sets)) +
  geom_bar(stat="identity", fill = "lightblue") +
  coord_flip() +
  labs(title = paste0("Top ", top_themes, " najpopularniejszych tematów na \npodstawie ilości setów"), x = "Theme name", y = "Sum of sets") +
  theme_bw() +
  theme(legend.position = "none")

ggplotly(top_n_themes_plot, tooltip = c("Count_sets"))
```

```{r}
top_themes_parents = 10
```

## Top `r top_themes_parents` tematów przewodnich
Warto zwrócić uwagę, że jeśli temat przewodni nie miał nadrzędnego tematu, to traktowany był on jako własny nadrzędny temat 
```{r}

top_n_parent_themes_df <- themes_with_parents_df %>%
  group_by(name_parent) %>%
  summarize(Count = n()) %>%
  arrange(desc(Count)) %>%
  head(top_themes_parents)

top_n_themes_plot <- ggplot(top_n_parent_themes_df, aes(x=reorder(name_parent, Count), y=Count)) +
  geom_bar(stat="identity", fill = "blue") +
  coord_flip() +
  labs(title = paste0("Top ", top_themes_parents, " najpopularniejszych tematów przewodnich"), x = "Theme name", y = "Count") +
  theme_bw() +
  theme(legend.position = "none")

ggplotly(top_n_themes_plot, tooltip = c("Count"))
```

## Suma setów oraz części dla każdego tematu
```{r}
sum_set_part_themes_df <- sets_themes_df %>%
  group_by(name_parent) %>%
  summarize(Count_sets = n(),
            Sum_parts = sum(num_parts))

colnames(sum_set_part_themes_df) <- c("Name_parent", "Count_sets", "Sum_parts")

sum_set_part_themes_plot <- ggplot(sum_set_part_themes_df, aes(x = Count_sets, y= Sum_parts, color = Name_parent)) + 
  geom_point() +
  theme_bw()

ggplotly(sum_set_part_themes_plot)
```

```{r}
top_part_categories = 20
```

## Top `r top_part_categories` najczęśniej występowanych kategorii części
```{r}
top_part_with_categories_df <- left_join(parts_clean, part_categories_clean, by = join_by(part_cat_id == id), suffix = c("_parts", "_categories")) %>%
  select(name_categories) %>%
  group_by(name_categories) %>%
  summarize(Count = n()) %>%
  arrange(desc(Count)) %>%
  head(top_part_categories)

top_n_themes_plot <- ggplot(top_part_with_categories_df, aes(x=reorder(name_categories, Count), y=Count)) +
  geom_bar(stat="identity", fill = "#4d7cc9") +
  coord_flip() +
  labs(x = "Category name", y = "Count") +
  theme_bw() +
  theme(legend.position = "none")

ggplotly(top_n_themes_plot, tooltip = c("Count"))

```

## Porównanie najczęstszych relacji między częściami
```{r}
sorted_top_part_relationships_df <- part_relationships_clean %>% 
  select(rel_type) %>%
  group_by(rel_type) %>%
  summarize(Count = n()) %>%
  arrange(desc(Count))

print(sorted_top_part_relationships_df)
```

## Korelacja
```{r}

```

## Animacja porównujące podstawowe statystyki dla setów w przeciągu lat
```{r}

```

## Korelacja między podstawowymi statystykami związanymi z setami
```{r}

```

# Podumowanie najważniejszych trendów w rozwoju Lego

# Przewidywanie dalszych cech zestawów Lego